############################### Version 1.4.0 #####################################
substitutions:
  rx_pin: GPIO48
  tx_pin: GPIO47
  interval_time: 20s

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

captive_portal:

esphome:
  name: rotex
  friendly_name: Rotex

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

globals:
  - id: backup_dhw
    type: int

  - id: interval_active
    type: bool
    restore_value: yes
    initial_value: 'true'


# Enable logging
logger:
  #level: VERBOSE

ota:
  platform: esphome
  password: !secret ota_password

web_server:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rotex Fallback Hotspot"
    password: "H3jGqANSa7aL"

############################## Text Sensoren ########################################
# sort by name:

text_sensor:
  - platform: template
    name: "Betriebsart"
    id: betriebsart

  - platform: template
    name: "Fehlercode"
    id: text_fehler
    lambda: |-
      if(id(Fehlercode).state == 0){
        return {"kein Fehler"};
      } else if (id(Fehlercode).state == 9001){
        return {" Fehler E9001 Fehler Rücklauffühler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9002){
        return {"Fehler E9002 Fehler Vorlauffühler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9003){
        return {"Fehler E9003 Fehler Frostschutzfunktion Handbuch S.60"};
      } else if (id(Fehlercode).state == 9004){
        return {"Fehler E9004Fehler Durchfluss Handbuch S.61"};
      } else if (id(Fehlercode).state == 9005){
        return {"9005 Vorlauftemperaturfühler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9006){
        return {"9006 Vorlauftemperaturfühler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9007){
        return {"9007 Platine IG defekt Handbuch S.60"};
      } else if (id(Fehlercode).state == 9008){
        return {"9008 Kältemitteltemperatur außerhalb des Bereiches Handbuch S.60"};
      } else if (id(Fehlercode).state == 9009){
        return {"9009 STB Fehler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9010){
        return {"9010 STB Fehler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9011){
        return {"9011 Fehler Flowsensor Handbuch S.60"};
      } else if (id(Fehlercode).state == 9012){
        return {"9012 Fehler Vorlauffühler Handbuch S.60"};
      } else if (id(Fehlercode).state == 9013){
        return {"9013 Platine AG defekt Handbuch S.60"};
      } else if (id(Fehlercode).state == 9014){
        return {"9014 P-Kältemittel hoch Handbuch S.61"};
      } else if (id(Fehlercode).state == 9015){
        return {"9015 P-Kältemittel niedrig Handbuch S.61"};
      } else if (id(Fehlercode).state == 9016){
        return {"9016 Lastschutz Verdichter Handbuch S.61"};
      } else if (id(Fehlercode).state == 9017){
        return {"9017 Ventilator blockiert Handbuch S.61"};
      } else if (id(Fehlercode).state == 9018){
        return {"9018 Expansionsventil Handbuch S.61"};
      } else if (id(Fehlercode).state == 9019){
        return {"9019 Warmwassertemperatur > 85°C Handbuch S.61"};
      } else if (id(Fehlercode).state == 9020){
        return {"9020 T-Verdampfer hoch Handbuch S.61"};
      } else if (id(Fehlercode).state == 9021){
        return {"9021 HPS-System Handbuch S.61"};
      } else if (id(Fehlercode).state == 9022){
        return {"9022 Fehler AT-Fühler Handbuch S.62"};
      } else if (id(Fehlercode).state == 9023){
        return {"9023 Fehler WW-Fühler Handbuch S.62"};
      } else if (id(Fehlercode).state == 9024){
        return {"9024 Drucksensor Handbuch S.62"};
      } else if (id(Fehlercode).state == 9025){
        return {"9025 Fehler Rücklauffühler Handbuch S.62"};
      } else if (id(Fehlercode).state == 9026){
        return {"9026 Drucksensor Handbuch S.62"};
      } else if (id(Fehlercode).state == 9027){
        return {"9027 Aircoil-Fühler Defrost Handbuch S.62"};
      } else if (id(Fehlercode).state == 9028){
        return {"9028 Aircoil-Fühler temp Handbuch S.62"};
      } else if (id(Fehlercode).state == 9029){
        return {"9029 Fehler Kältefühler AG handbuch S.62"};
      } else if (id(Fehlercode).state == 9030){
        return {"9030 Defekt elektrisch Handbuch S.63"};
      } else if (id(Fehlercode).state == 9031){
        return {"9031 Defekt elektrisch Handbuch S.63"};
      } else if (id(Fehlercode).state == 9032){
        return {"9032 Defekt elektrisch Handbuch S.63"};
      } else if (id(Fehlercode).state == 9033){
        return {"9033 Defekt elektrisch Handbuch S.63"};
      } else if (id(Fehlercode).state == 9034){
        return {"9034 Defekt elektrisch Handbuch S.63"};
      } else if (id(Fehlercode).state == 9035){
        return {"9035 Platine AG defekt Handbuch S.63"};
      } else if (id(Fehlercode).state == 9036){
        return {"9036 Defekt elektrisch Handbuch S.63"};
      } else if (id(Fehlercode).state == 9037){
        return {"9037 Einstellung Leistung Handbuch S.63"};
      } else if (id(Fehlercode).state == 9038){
        return {"9038 Kältemittel Leck Handbuch S.64"};
      } else if (id(Fehlercode).state == 9039){
        return {"9039 Unter/Überspannung Handbuch S.64"};
      } else if (id(Fehlercode).state == 9041){
        return {"9041 Übertragungsfehler Handbuch S.64"};
      } else if (id(Fehlercode).state == 9042){
        return {"9042 Übertragungsfehler Handbuch S.64"};
      } else if (id(Fehlercode).state == 9043){
        return {"9043 Übertragungsfehler Handbuch S.64"};
      } else if (id(Fehlercode).state == 9044){
        return {"9044 Übertragungsfehler Handbuch S.64"};
      } else if (id(Fehlercode).state == 75){
        return {"75 Fehler Außentemperaturfühler Handbuch S.64"};
      } else if (id(Fehlercode).state == 76){
        return {"76 Fehler Speichertemperaturfühler Handbuch S.64"};
      } else if (id(Fehlercode).state == 81){
        return {"81 Kommunikationsfehler Rocon Handbuch S.64"};
      } else if (id(Fehlercode).state == 88){
        return {"88 Kommunikationsfehler Rocon Handbuch S.6"};
      } else if (id(Fehlercode).state == 91){
        return {"91 Kommunikationsfehler Rocon Handbuch S.6"};
      } else if (id(Fehlercode).state == 128){
        return {"128 Fehler Rücklauftemperaturfühler Handbuch S.64"};
      } else if (id(Fehlercode).state == 129){
        return {"129 Fehler Drucksensor Handbuch S.64"};
      } else if (id(Fehlercode).state == 198){
        return {"198 Durchflussmessung nicht plausibel Handbuch S.65"};
      } else if (id(Fehlercode).state == 200){
        return {"200 Kommunikationsfehler Handbuch S.65"};
      } else if (id(Fehlercode).state == 8005){
        return {"8005 Wasserdruck in Heizungsanlage zu gering Handbuch S.65"};
      } else if (id(Fehlercode).state == 8100){
        return {"8100 Kommunikation Handbuch S.65"};
      } else if (id(Fehlercode).state == 9000){
        return {"9000 Interne vorübergehende Meldung Handbuch S65"};
      } else if (id(Fehlercode).state == 8006){
        return {"8006 Warnung Druckverlust Handbuch S.65"};
      } else if (id(Fehlercode).state == 8007){
        return {"8007 wasserdruck in Anlage zu hoch Handbuch S.65"};
      } else {
        return {"Unknown"};
      }

  - platform: template
    name: "SG Modus"
    id: sg_modus

  - platform: template
    name: "Smart Grid"
    id: smartgrid

  - platform: template
    name: "Status Kesselpumpe"
    id: status_kessel

  - platform: template
    name: "Status Kompressor"
    id: status_kompressor

################################ Button und Switch ##############################################
# sorted on name:

button:

  - platform: gpio
    name: "Heizen Thermostat"
    pin: GPIO36

switch:
  - platform: template
    name: "Intervall Abfrage"
    optimistic: true
    turn_on_action:
      - globals.set:
          id: interval_active
          value: 'true'
    turn_off_action:
      - globals.set:
          id: interval_active
          value: 'false'

  - platform: gpio
    name: "Kühlen Thermostat"
    pin: GPIO37

  - platform: template
    name: "Warmwasser bereiten"
    id: ww_button
    icon: "mdi:water-boiler"
    on_press:
      then:
        - globals.set:
            id: backup_dhw
            value: !lambda return int(id(dhw_setpoint).state * 10);
        - canbus.send:
            can_id: 0x680
            data: [0x30, 0x00, 0x13, 0x02, 0xBC, 0x00, 0x00] # 70 Grad Grundeinstellung
        - delay: 10s
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              uint16_t temperature = (uint16_t)id(backup_dhw); // Convert to int16be
              uint8_t high_byte = temperature >> 8;
              uint8_t low_byte = temperature & 0xFF;
              return {0x30, 0x00, 0x13, high_byte, low_byte, 0x00, 0x00};
        - logger.log: CAN Nachricht wurde gesendet

  - platform: restart
    name: "Rotex ESP Restart"

############################### Number (Box) ###############################################
# sorted on name:

number:

##### DHW setpoint
  - platform: template
    name: "DHW setpoint"
    id: dhw_setpoint
    optimistic: true
    mode: box
    min_value: 35
    max_value: 70
    step: 0.5
    initial_value: 45
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0x13, high_byte, low_byte, 0x00, 0x00 };
      - logger.log:
          format: "DHW setpoint set to %f"
          args: [ 'id(dhw_setpoint).state' ]

#### Heizkurve
  - platform: template
    name: "Heizkurve"
    id: heizkurve
    optimistic: true
    mode: box
    min_value: 0
    max_value: 3
    step: 0.01
    initial_value: 0.48
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t hk = (uint16_t)(x * 100); // Convert to int16be
            uint8_t high_byte = hk >> 8;
            uint8_t low_byte = hk & 0xFF;
            return { 0x30, 0x00, 0xFA, 0x01, 0x0E, high_byte, low_byte };
      - logger.log:
          format: "Heizkurve set to %f"
          args: [ 'id(heizkurve).state' ]

##### Max VL Set
  - platform: template
    name: "Max VL Einstellen"
    id: max_vl_set
    optimistic: true
    mode: box
    min_value: 25
    max_value: 60
    step: 1
    initial_value: 35
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0x28, high_byte, low_byte, 0x00, 0x00, };
      - logger.log:
          format: "Max VL set to %f"
          args: [ 'id(max_vl_set).state' ]

##### Min VL
  - platform: template
    name: "Min VL"
    id: min_vl
    optimistic: true
    mode: box
    min_value: 10
    max_value: 70
    step: 1
    initial_value: 25
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0xFA, 0x01, 0x2B, high_byte, low_byte };
      - logger.log:
          format: "Min VL set to %f"
          args: [ 'id(min_vl).state' ]

##### Raumsoll 1
  - platform: template
    name: "Raumsoll 1"
    id: raumsoll1
    optimistic: true
    mode: box
    min_value: 5
    max_value: 40
    step: 0.1
    initial_value: 19
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0x05, high_byte, low_byte, 0x00, 0x00 };
      - logger.log:
          format: "Raumsoll 1 set to %f"
          args: [ 'id(raumsoll1).state' ]

##### T Vorlauf Tag Set
  - platform: template
    name: "T Vorlauf Tag Einstellen"
    id: t_vorlauf_tag_set
    optimistic: true
    mode: box
    min_value: 25
    max_value: 60
    step: 1
    initial_value: 35
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0xFA,  0x01, 0x29, high_byte, low_byte, };
      - logger.log:
          format: "T Vorlauf Tag set to %f"
          args: [ 'id(t_vorlauf_tag_set).state' ]

####################### Select Tasten ###############################
# sorted on id:

#Set Betriebsmodus
select:
  - platform: template
    name: "Betriebsmodus"
    id: betrieb
    optimistic: true
    options:
      - "Heizen"
      - "Bereitschaft"
      - "Absenken"
      - "Sommer"
      - "Kühlen"
      - "Automatik 1"
      - "Automatik 2"
    initial_option: Heizen
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Heizen", 3},
                {"Bereitschaft", 1},
                {"Absenken", 4},
                {"Sommer", 5},
                {"Kühlen", 17},
                {"Automatik 1", 11},
                {"Automatik 2", 12}
              };
              return {0x30, 0x00, 0xFA, 0x01, 0x12, mode_map.at(x), 0x00};
        - logger.log:
            format: "Betriebsmodus set to %s"
            args: [ 'id(betrieb).state.c_str()' ]

#Set HK Funktion
  - platform: template
    name: "HK Funktion"
    id: hk
    optimistic: true
    options:
      - "Witterungsgeführt"
      - "Fest"
    initial_option: Witterungsgeführt
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Witterungsgeführt", 0},
                {"Fest", 1}
              };
              return {0x30, 0x00, 0xFA, 0x01, 0x41, 0x00, mode_map.at(x)};

#Set SG Funktion
  - platform: template
    name: "SG Modus"
    id: sg
    optimistic: true
    options:
      - "Aus"
      - "SG Modus 1"
      - "SG Modus 2"
    initial_option: Aus
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Aus", 0},
                {"SG Modus 1", 1},
                {"SG Modus 2", 2}
              };
              return {0x30, 0x00, 0xFA, 0x06, 0x94, 0x00, mode_map.at(x)};


#Set Smart Grid
  - platform: template
    name: "Smart Grid"
    id: smartgrid
    optimistic: true
    options:
      - "Aus"
      - "An"
    initial_option: Aus
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Aus", 0},
                {"An", 1}
              };
              return {0x30, 0x00, 0xFA, 0x06, 0x93, 0x00, mode_map.at(x)};


################################# Alle Sensoren #####################################
# sorted on id:
sensor:

  - platform: wifi_signal
    name: "WiFi Signal Sensor"
    update_interval: 60s

  - platform: template
    name: "Fehlercode"
    id: Fehlercode
    internal: true
    unit_of_measurement: ""
    icon: "mdi:thermometer-lines"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Thermische Leistung"
    device_class: "power"
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    update_interval: 10s
    lambda: |-
      if (id(betriebsart).state == "Warmwasserbereitung") {
        return ((id(tv1).state - id(ruecklauf).state) * (4.19 * id(durchfluss).state)) / 3600;
      } else if (id(betriebsart).state == "Heizen") {
        return ((id(TVBH).state - id(ruecklauf).state) * (4.19 * id(durchfluss).state)) / 3600;
      } else {
        return 0.0;
      }
#     if (id(status_kessel).state == 1) {
#         const float tv1_state = id(tv1).state;
#         const float ruecklauf_state = id(ruecklauf).state;
#         const float durchfluss_state = id(durchfluss).state;
#         return ((tv1_state - ruecklauf_state) * (4.19 * durchfluss_state)) / 3600;
#     } else {
#         return 0.0; // oder einen anderen Wert, wenn der Kompressor nicht aktiv ist
#     }
#         const float TVBH_state = id(TVBH).state;
#         return ((TVBH_state - ruecklauf_state) * (4.91 * durchfluss_state)) / 3600;

  # - platform: template
  #   name: "Rocon u1"
  #   id: t_room
  #   unit_of_measurement: "°C"
  #   icon: "mdi:thermometer-lines"
  #   device_class: "temperature"
  #   state_class: "measurement"
  #   accuracy_decimals: 1

  - platform: template
    name: "Wasserdruck (DS)"
    id: Wasserdruck
    unit_of_measurement: "bar"
    icon: "mdi:thermometer-lines"
    device_class: "pressure"
    state_class: "measurement"
    accuracy_decimals: 2

  - platform: template
    name: "Erzeugte Energie Gesamt"
    id: Erzeugte_Energie_Gesamt
    unit_of_measurement: "kWh"
    icon: "mdi:thermometer-lines"
    device_class: "ENERGY_STORAGE"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "EHS fuer DHW (Qboh)"
    id: Qboh
    unit_of_measurement: "kWh"
    icon: "mdi:thermometer-lines"
    device_class: "ENERGY_STORAGE"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "EHS fuer CH (Qchhp)"
    id: Qchhp
    unit_of_measurement: "kWh"
    icon: "mdi:thermometer-lines"
    device_class: "ENERGY_STORAGE"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Qsc"
    id: Qsc
    unit_of_measurement: "kWh"
    icon: "mdi:thermometer-lines"
    device_class: "ENERGY_STORAGE"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Qch"
    id: Qch
    unit_of_measurement: "kWh"
    icon: "mdi:thermometer-lines"
    device_class: "ENERGY_STORAGE"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Qdhw"
    id: Qdhw
    unit_of_measurement: "kWh"
    icon: "mdi:thermometer-lines"
    device_class: "ENERGY_STORAGE"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Umwaelzpumpe"
    id: Umwaelzpumpe
    unit_of_measurement: "%"
    icon: "mdi:thermometer-lines"
    device_class: "battery"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Vorlauf Soll"
    id: vl_soll
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1

  - platform: template
    name: "Aussentemperatur (TA)"
    id: TA
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1

  - platform: template
    name: "Warmwassertemperatur (TDHW)"
    id: temperature_water
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1

  - platform: template
    name: "Vorlauftemperatur Heizung (TVBH)"
    id: TVBH
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-right"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1

  - platform: template
    name: "Heizkreis Vorlauf (tv1)"
    id: tv1
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-right"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1

  - platform: template
    name: "Ruecklauftemperatur Heizung"
    id: ruecklauf
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-left"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1

  - platform: template
    name: "Durchfluss"
    id: durchfluss
    unit_of_measurement: "ltr/h"
    icon: "mdi:waves-arrow-left"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Laufzeit Compressor"
    id: rt_compressor
    unit_of_measurement: "h"
    icon: "mdi:icon-time"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Laufzeit Pump"
    id: rt_pump
    unit_of_measurement: "h"
    icon: "mdi:icon-time"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "BPV"
    id: BPV
    unit_of_measurement: "%"
    icon: "mdi:waves-arrow-left"
    accuracy_decimals: 0

  - platform: template
    name: "Mixer Position (3UV_DHW)"
    id: mixpos
    unit_of_measurement: "%"
    icon: "mdi:waves-arrow-left"
    accuracy_decimals: 0

  - platform: template
    name: "Max VL Soll"
    internal: false
    id: max_vl_soll
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-left"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Spreizung MOD HZ"
    internal: false
    id: spreizung_mod_hz
    unit_of_measurement: "K"
    icon: "mdi:waves-arrow-left"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "Spreizung MOD WW"
    internal: false
    id: spreizung_mod_ww
    unit_of_measurement: "K"
    icon: "mdi:waves-arrow-left"
    state_class: "measurement"
    accuracy_decimals: 0

  - platform: template
    name: "T Vorlauf Tag"
    internal: false
    id: t_vorlauf_tag
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-left"
    state_class: "measurement"
    accuracy_decimals: 0

########################### CAN Nachrichten abfragen #################################################
interval:
  - interval:  ${interval_time}
    then:
      if:
        condition:
          - lambda: 'return id(interval_active);'
        then:
          #Status Kessel
          - canbus.send:
              data: [0x31, 0x00, 0xFA, 0x0A, 0x8C, 0x00, 0x00]
              can_id: 0x680
          - delay: 500ms

canbus:
  - platform: esp32_can
    tx_pin: ${tx_pin}
    rx_pin: ${rx_pin}
    can_id: 0x680
    bit_rate: 20kbps
    id: can_bus
    on_frame:

################################# CAN Nachrichten empfangen (Auswertung) #####################################
# sorted on can message

#Max. VL Soll
# SvdE not showing up in regular chatter
# Q: 190   [7]  61 00 28 00 00 00 00
# A: 300   [7]  32 10 28 03 20 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xD2 && x[2]==0x28) {
              float temperature = float((float((int((x[4])+((x[3])<<8))))/10));
              id(max_vl_soll).publish_state(temperature);
              auto call = id(max_vl_set).make_call();
              call.set_value(temperature);
              call.perform();     
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Wasserdruck (DS)
# SvdE not showing up in regular chatter
# Q: 190   [7]  31 00 1C 00 00 00 00
# A: 180   [7]  32 10 1C 03 AD 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0x32 && x[1]==0x10 && x[2]==0x1C) {
              float temperature = float((float((int((x[4])+((x[3])<<8))))/1000));
              id(Wasserdruck).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Raumsoll1
# Q: 69D   [7]  31 00 FA 00 05 00 00
# A: 180   [7]  D2 1D FA 00 05 00 C8 = 200 / 10 = 20.0
# Q: 69D   [7]  61 00 FA 00 05 00 00
# A: 300   [7]  D2 1D FA 00 05 00 C8 = 200 / 10 = 20.0
# Q: 69D   [7]  C1 00 FA 00 05 00 00
# A: 600   [7]  D2 1D FA 00 05 00 C8 = 200 / 10 = 20.0
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x00 && x[4]==0x05) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/10));
              id(raumsoll1).publish_state(temperature);
            }

# TA
# Q: 69D   [7]  31 00 FA 00 0C 00 00
# A: 180   [7]  D2 1D FA 00 0C 00 B9 = 185 = 18.5
# Q: 69D   [7]  61 00 FA 00 0C 00 00
# A: 300   [7]  D2 1D FA 00 0C 80 00
# Q: 69D   [7]  C1 00 FA 00 0C 00 00
# A: 600   [7]  D2 1D FA 00 0C 00 B9 = 185 = 18.5
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x00 && x[4]==0x0C) {
              float temperature = float(((int((x[6])+((x[5])<<8))) ^ 0x8000) - 0x8000)/10;
              id(TA).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }
    - can_id: 0x600
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x00 && x[4]==0x0C) {
              float temperature = float(((int((x[6])+((x[5])<<8))) ^ 0x8000) - 0x8000)/10;
              id(TA).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Warmwasser-Temperaturabfrage
# Q: 69D   [7]  31 00 FA 00 0E 00 00
# A: 180   [7]  D2 1D FA 00 0E 01 E6
# 300 and 600 always respond with D2 1D FA 00 0E 80 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x00 && x[4]==0x0E) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/10));
              id(temperature_water).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Rocon u1 - only works if you have this room station.
# Q: 69D   [7]  31 00 FA 00 11 00 00
# A: 180   [7]  D2 1D FA 00 11 80 00 = 32768
# Q: 69D   [7]  61 00 FA 00 11 00 00
# A: 300   [7]  D2 1D FA 00 11 FE 70 = 65136
# Q: 69D   [7]  C1 00 FA 00 11 00 00
# A: 600   [7]  D2 1D FA 00 11 80 00 = 32768
    # - can_id: 0x180
    #   then:
    #     - lambda: |-
    #         if(x[2]==0xFA && x[3]==0x00 && x[4]==0x11) {
    #          float temperature = float((float((int((x[6])+((x[5])<<8))))/100));
    #          id(t_room).publish_state(temperature);
    #          ESP_LOGD("main", "Temperature received over can is %f", temperature);
    #         }

#DHW setpoint
# Q: 69D   [7]  31 00 FA 00 13 00 00
# A: 180   [7]  D2 1D FA 00 13 01 E0
# Q: 69D   [7]  61 00 FA 00 13 00 00
# A: 300   [7]  D2 1D FA 00 13 01 E0
# Q: 69D   [7]  C1 00 FA 00 13 00 00
# A: 600   [7]  D2 1D FA 00 13 01 E0
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x00 && x[4]==0x13) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(dhw_setpoint).publish_state(temperature);
              ESP_LOGD("main", "dhw_setpoint received over can is %f", temperature);
            }

#Rücklauftemperaturabfrage (t_r1)
# 69D   [7]  31 00 FA 00 16 00 00
# 180   [7]  D2 1D FA 00 16 00 EF = 239 / 10 = 23.9
# 69D   [7]  61 00 FA 00 16 00 00
# 300   [7]  D2 1D FA 00 16 80 00
# 69D   [7]  C1 00 FA 00 16 00 00
# 600   [7]  D2 1D FA 00 16 80 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x00 && x[4]==0x16) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(ruecklauf).publish_state(temperature);
              ESP_LOGD("main", "ruecklauf received over can is %f", temperature);
            }

#Heizkurve
# Q: 69D   [7]  31 00 FA 01 0E 00 00
# A: 180   [7]  D2 1D FA 01 0E 00 32 = 50 / 10 = 0.5
# Q: 69D   [7]  61 00 FA 01 0E 00 00
# A: 300   [7]  D2 1D FA 01 0E 00 32 = 50 / 10 = 0.5
# Q: 69D   [7]  C1 00 FA 01 0E 00 00
# A: 600   [7]  D2 1D FA 01 0E 00 32 = 50 / 10 = 0.5
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x0E) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/100));
              id(heizkurve).publish_state(temperature);
              ESP_LOGD("main", "heizkurve received over can is %f", temperature);
            }

    - can_id: 0x300
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x0E) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/100));
              id(heizkurve).publish_state(temperature);
              ESP_LOGD("main", "heizkurve received over can is %f", temperature);
            }

    - can_id: 0x600
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x0E) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/100));
              id(heizkurve).publish_state(temperature);
              ESP_LOGD("main", "heizkurve received over can is %f", temperature);
            }

#Betriebsmodus (Automatik bei jeglicher Änderung)0x31, 0x00, 0xFA, 0x01, 0x12, 0x00, 0x00
# Q: 69D   [7]  31 00 FA 01 12 00 00
# A: 180   [7]  D2 1D FA 01 12 05 00 (summer)
# Q: 69D   [7]  61 00 FA 01 12 00 00
# A: 300   [7]  D2 1D FA 01 12 05 00 (summer)
# Q: 69D   [7]  C1 00 FA 01 12 00 00
# A: 600   [7]  D2 1D FA 01 12 05 00 (summer)
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x12) {
              if (x[5]==0x01){ id(betrieb).publish_state("Bereitschaft"); }
              else if (x[5]==0x03){ id(betrieb).publish_state("Heizen"); }
              else if (x[5]==0x04){ id(betrieb).publish_state("Absenken"); }
              else if (x[5]==0x05){ id(betrieb).publish_state("Sommer"); }
              else if (x[5]==0x17){ id(betrieb).publish_state("Kühlen"); }
              else if (x[5]==0x0B){ id(betrieb).publish_state("Automatik 1"); }
              else if (x[5]==0x0C){ id(betrieb).publish_state("Automatik 2"); }
            }

#T Vorlauf Tag
# Q: 69D   [7]  31 00 FA 01 29 00 00
# A: 180   [7]  D2 1D FA 01 29 01 90
# Q: 69D   [7]  61 00 FA 01 29 00 00
# A: 300   [7]  D2 1D FA 01 29 01 90
# Q: 69D   [7]  C1 00 FA 01 29 00 00
# A: 600   [7]  D2 1D FA 01 29 01 90
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x29) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(t_vorlauf_tag).publish_state(temperature);   
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Min. VL Soll
# Q: 69D   [7]  31 00 FA 01 2B 00 00
# A: 180   [7]  D2 1D FA 01 2B 00 64 = 100 / 10 = 10
# Q: 69D   [7]  61 00 FA 01 2B 00 00
# A: 300   [7]  D2 1D FA 01 2B 00 64 = 100 / 10 = 10
# Q: 69D   [7]  C1 00 FA 01 2B 00 00
# A: 600   [7]  D2 1D FA 01 2B 00 64 = 100 / 10 = 10
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x2B) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(min_vl).publish_state(temperature);    
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#HK Funktion (Automatik bei jeglicher Änderung)0x31, 0x00, 0xFA, 0x01, 0x41, 0x00, 0x00
# Q: 69D   [7]  31 00 FA 01 41 00 00
# A: 180   [7]  D2 1D FA 01 41 00 00
# QL 69D   [7]  61 00 FA 01 41 00 00
# A: 300   [7]  D2 1D FA 01 41 00 00
# Q: 69D   [7]  C1 00 FA 01 41 00 00
# A: 600   [7]  D2 1D FA 01 41 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0x41 && x[5]==0x00) {
              if (x[6]==0x00){
                id(hk).publish_state("Witterungsgeführt"); }
              else if (x[6]==0x01) {
                id(hk).publish_state("Fest"); }
              }

#Vorlauftemperaturabfrage Heizkreis (tv1)
# A: can0  180   [7]  20 0A FA 01 D6 01 1C
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0xD6) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(tv1).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Volumenstrom
# 180, 300 and 600 respod with correct values
# Q: 69D   [7]  31 00 FA 01 DA 00 00
# A: 180   [7]  D2 1D FA 01 DA 06 93
# Q: 69D   [7]  61 00 FA 01 DA 00 00
# A: 300   [7]  D2 1D FA 01 DA 06 7C
# Q  69D   [7]  C1 00 FA 01 DA 00 00
# A: 600   [7]  D2 1D FA 01 DA 06 66
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0xDA) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(durchfluss).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }
    - can_id: 0x300
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0xDA) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(durchfluss).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }
    - can_id: 0x600
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x01 && x[4]==0xDA) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(durchfluss).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Spreizung MOD HZ
# Q: 69D   [7]  31 00 FA 06 83 00 00
# A: 180   [7]  D2 1D FA 06 83 00 46 = 70
# Q: 69D   [7]  61 00 FA 06 83 00 00
# A: 300   [7]  D2 1D FA 06 83 00 46 = 70
# Q: 69D   [7]  C1 00 FA 06 83 00 00
# A: 600   [7]  D2 1D FA 06 83 00 46 = 70
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0x83) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/10));
              id(spreizung_mod_hz).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Spreizung MOD WW
# Q: 69D   [7]  31 00 FA 06 84 00 00
# A: 180   [7]  D2 1D FA 06 84 00 14 = 20
# Q: 69D   [7]  61 00 FA 06 84 00 00
# A: 300   [7]  D2 1D FA 06 84 00 14 = 20
# Q: 69D   [7]  C1 00 FA 06 84 00 00
# A: 600   [7]  D2 1D FA 06 84 00 14 = 20
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0x84) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))/10));
              id(spreizung_mod_ww).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#SGModus
# 69D   [7]  31 00 FA 06 94 00 00
# 180   [7]  D2 1D FA 06 94 00 01
# 69D   [7]  61 00 FA 06 94 00 00
# 300   [7]  D2 1D FA 06 94 00 01
# 69D   [7]  C1 00 FA 06 94 00 00
# 600   [7]  D2 1D FA 06 94 00 01
# according to pyHPSU: "comfort" : "0", "standard" : "1", "eco" : "2"
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0x94) {
              float temperature =float((float((int((x[6])+((x[5])<<8))))));
              if (x[5]==0x00){ id(SGModus).publish_state("Aus"); }
              else if (x[5]==0x01){ id(SGModus).publish_state("SG Modus 1"); }
              else if (x[5]==0x02){ id(SGModus).publish_staye("SG Modus 2"); }
              else id(SGModus).publish_state("Unknown");
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

# MixPos (3UV_DHW)
# Q: 69D   [7]  31 00 FA 06 9B 00 00
# A: 180   [7]  D2 1D FA 06 9B 00 64 = 100
# Q: 69D   [7]  61 00 FA 06 9B 00 00
# A: 300   [7]  D2 1D FA 06 9B 00 64 = 100
# Q: 69D   [7]  C1 00 FA 06 9B 00 00
# A: 600   [7]  D2 1D FA 06 9B 00 64 = 100
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0x9B) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(mixpos).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#rt_pump
# Q: 69D   [7]  31 00 FA 06 A4 00 00
# A: 180   [7]  D2 1D FA 06 A4 00 01
# Q: 69D   [7]  61 00 FA 06 A4 00 00
# A: 300   [7]  D2 1D FA 06 A4 00 01
# Q: 69D   [7]  C1 00 FA 06 A4 00 00
# A: 600   [7]  D2 1D FA 06 A4 00 01
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0xA4) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(rt_pump).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#rt_compressor
# Q: 69D   [7]  31 00 FA 06 A5 00 00
# A: 180   [7]  D2 1D FA 06 A5 00 01
# Q: 69D   [7]  61 00 FA 06 A5 00 00
# A: 300   [7]  D2 1D FA 06 A5 00 01
# Q: 69D   [7]  C1 00 FA 06 A5 00 00
# A: 600   [7]  D2 1D FA 06 A5 00 01
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0xA5) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(rt_compressor).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Qsc
# Q: 680   [7]  31 00 FA 06 A6 00 00
# A: 180   [7]  D2 00 FA 06 A6 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0xA6) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(Qsc).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Qch
# Q: 680   [7]  61 00 FA 06 A7 00 00
# A: 300   [7]  D2 00 FA 06 A7 00 00
    - can_id: 0x300
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x06 && x[4]==0xA7) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(Qch).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Qchhp
# Q: 680   [7]  31 00 FA 09 20 00 00
# A: 180   [7]  D2 00 FA 09 20 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x09 && x[4]==0x20) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(Qchhp).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Erzeugte Energie gesamt | Qwp
# Q: 680   [7]  31 00 FA 09 30 00 00
# A: 180   [7]  D2 00 FA 09 30 00 08
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x09 && x[4]==0x30) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(Erzeugte_Energie_Gesamt).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Qboh
# Q: 680   [7]  31 00 FA 09 1C 00 00
# A: 180   [7]  D2 00 FA 09 1C 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x09 && x[4]==0x1C) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(Qboh).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Qdhw
# Q: 680   [7]  31 00 FA 09 2C 00 00
# A: 180   [7]  D2 00 FA 09 2C 00 08
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x09 && x[4]==0x2C) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(Qdhw).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Außentemperaturabfrage (TA)
# I thought this was (TA), but it's not. Slightly warmer temp reading.
# Q: 69D   [7]  31 00 FA 0A 0C 00 00
# A: 180   [7]  D2 1D FA 0A 0C 80 00
# Q: 69D   [7]  61 00 FA 0A 0C 00 00
# A: 300   [7]  D2 1D FA 0A 0C 00 CA
# Q: 69D   [7]  C1 00 FA 0A 0C 00 00
# A: 600   [7]  D2 1D FA 0A 0C 80 00
    # - can_id: 0x300
    #   then:
    #     - lambda: |-
    #         if(x[2]==0xFA && x[3]==0x0A && x[4]==0x0C) {
    #           float temperature = float(((int((x[6])+((x[5])<<8))) ^ 0x8000) - 0x8000)/10;
    #           id(TA).publish_state(temperature);
    #           ESP_LOGD("main", "Temperature received over can is %f", temperature);
    #         }

#Fehlercode
# Q: 69D   [7]  31 00 FA 13 88 00 00
# A: 180   [7]  D2 1D FA 13 88 00 00
# Q: 69D   [7]  61 00 FA 13 88 00 00
# A: 300   [7]  D2 1D FA 13 88 00 00
# Q: 69D   [7]  C1 00 FA 13 88 00 00
# A: 600   [7]  D2 1D FA 13 88 00 00
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x13 && x[4]==0x88) {
             float temperature = float((float((int((x[6])+((x[5])<<8))))/100));
             id(Fehlercode).publish_state(temperature);
             ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Betriebsart
# Q: 69D   [7]  31 00 FA C0 F6 00 00
# A: 180   [7]  D2 1D FA C0 F6 00 04
# Q: 69D   [7]  61 00 FA C0 F6 00 00
# A: 300   [7]  D2 1D FA C0 F6 00 04
# Q: 69D   [7]  C1 00 FA C0 F6 00 00
# A: 600   [7]  D2 1D FA C0 F6 00 04
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xF6) {
              if (x[6]==0x00) { id(betriebsart).publish_state("Standby");
              } else if (x[6]==0x01) { id(betriebsart).publish_state("Heizen");
              } else if (x[6]==0x02) { id(betriebsart).publish_state("Kühlen");
              } else if (x[6]==0x03) { id(betriebsart).publish_state("Abtauen");
              } else if (x[6]==0x04) { id(betriebsart).publish_state("Warmwasserbereitung");
              } else { id(betriebsart).publish_state("Unknown");
              }
            }
    - can_id: 0x300
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xF6) {
              if (x[6]==0x00) { id(betriebsart).publish_state("Standby");
              } else if (x[6]==0x01) { id(betriebsart).publish_state("Heizen");
              } else if (x[6]==0x02) { id(betriebsart).publish_state("Kühlen");
              } else if (x[6]==0x03) { id(betriebsart).publish_state("Abtauen");
              } else if (x[6]==0x04) { id(betriebsart).publish_state("Warmwasserbereitung");
              } else { id(betriebsart).publish_state("Unknown");
              }
            }
    - can_id: 0x600
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xF6) {
              if (x[6]==0x00) { id(betriebsart).publish_state("Standby");
              } else if (x[6]==0x01) { id(betriebsart).publish_state("Heizen");
              } else if (x[6]==0x02) { id(betriebsart).publish_state("Kühlen");
              } else if (x[6]==0x03) { id(betriebsart).publish_state("Abtauen");
              } else if (x[6]==0x04) { id(betriebsart).publish_state("Warmwasserbereitung");
              } else { id(betriebsart).publish_state("Unknown");
              }
            }
# float temperature = float((float((int((x[6])+((x[5])<<8))))));
# id(text_betriebsart).publish_state(temperature);

#Umwälzpumpe
# Q: 69D   [7]  31 00 FA C0 F7 00 00
# A: 180   [7]  D2 1D FA C0 F7 00 64 = 100
# Q: 69D   [7]  61 00 FA C0 F7 00 00
# A: 300   [7]  D2 1D FA C0 F7 00 64 = 100
# Q: 69D   [7]  C1 00 FA C0 F7 00 00
# A: 600   [7]  D2 1D FA C0 F7 00 64 = 100
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xF7) {
             float temperature = float((float((int((x[6])+((x[5])))))));
             id(Umwaelzpumpe).publish_state(temperature);
             ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#BPV
# 180, 300 and 600 respod with correct values
# Q: 69D   [7]  31 00 FA C0 FB 00 00
# A: 180   [7]  D2 1D FA C0 FB 00 64 = 100
# Q: 69D   [7]  61 00 FA C0 FB 00 00
# A: 300   [7]  D2 1D FA C0 FB 00 64 = 100
# Q: 69D   [7]  C1 00 FA C0 FB 00 00
# A: 600   [7]  D2 1D FA C0 FB 00 64 = 100
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xFB) {
              float temperature = float((float((int((x[6])+((x[5])<<8))))));
              id(BPV).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Vorlauftemperaturabfrage (TVBH) - from pyHPSU
# Q: 69D   [7]  31 00 FA C0 FE 00 00
# A: 180   [7]  D2 1D FA C0 FE 01 5D = 349 /10 = 34.9
# Q: 69D   [7]  61 00 FA C0 FE 00 00
# A: 300   [7]  D2 1D FA C0 FE 01 5F = 351 / 10 = 35.1
# Q: 69D   [7]  C1 00 FA C0 FE 00 00
# A: 600   [7]  D2 1D FA C0 FE 01 5F = 351 / 10 = 35.1
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xFE) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(TVBH).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            } 
    - can_id: 0x300
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xFE) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(TVBH).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            } 
    - can_id: 0x600
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xFE) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(TVBH).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            } 

#Vorlauftemperaturabfrage (TVBH)
# Q: 69D   [7]  31 00 FA C1 02 00 00
# A: 180   [7]  D2 1D FA C1 02 01 DD = 477
# Q: 69D   [7]  61 00 FA C1 02 00 00
# A: 300   [7]  D2 1D FA C1 02 01 DD = 477
# Q: 69D   [7]  C1 00 FA C1 02 00 00
# A: 600   [7]  D2 1D FA C1 02 01 DE = 478
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC1 && x[4]==0x02) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(TVBH).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }
    - can_id: 0x300
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC1 && x[4]==0x02) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(TVBH).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }
    - can_id: 0x600
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0xC1 && x[4]==0x02) {
              float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
              id(TVBH).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Vorlauftemperaturabfrage (tdhw2)
# Q: 190   [7]  31 00 FA C1 06 00 00
# A: 180   [7]  32 10 FA C1 06 01 D0 - 464 / 10 = 46.4
    # - can_id: 0x180
    #   then:
    #     - lambda: |-
    #         if(x[2]==0xFA && x[3]==0xC1 && x[4]==0x06) {
    #           float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
    #           id(tdhw2).publish_state(temperature);
    #           ESP_LOGD("main", "Temperature received over can is %f", temperature);
    #         }

#Vorlauftemperaturabfrage Heizkreis (tv1)
# FA C0 FC
# SvdE not found in chatter, only when queried
    # - can_id: 0x180
    #   then:
    #     - lambda: |-
    #         if(x[2]==0xFA && x[3]==0xC0 && x[4]==0xFC) {
    #           float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
    #           id(TV).publish_state(temperature);
    #           ESP_LOGD("main", "Temperature received over can is %f", temperature);
    #         }

#Rücklauftemperaturabfrage (t_r1) FA C1 00
# replaced by FA 00 16
    # - can_id: 0x180
    #   then:
    #     - lambda: |-
    #         if(x[0]==0xD2 && x[1]==0x00 && x[3]==0xC1 && x[4]==0x00) {
    #           float temperature = float(float((int((x[6])+((x[5])<<8))))/10);
    #           id(ruecklauf).publish_state(temperature);
    #           ESP_LOGD("main", "Temperature received over can is %f", temperature);
    #         }

#WW_Soll_Set 0x30, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00 (Automatik bei jeglicher Änderung)
# SvdE: strange, need to look into this one. I've implemented a listening one that update dhw_setpoint. FA 00 13
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xD2 && x[1]==0x00 && x[2]==0x13 && x[5]==0x00 && x[6]==0x00) {
              uint16_t temperature_raw = (x[3] << 8) | x[4]; // Convert to int16be
              float temperature = static_cast<float>(temperature_raw) / 10.0;
              id(dhw_setpoint).publish_state(temperature);
            }

#Status Kessel
# SvdE: mot requested by rocon-g1
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[2]==0xFA && x[3]==0x0A && x[4]==0x8C) {
              if (x[6]==0x00) { id(status_kessel).publish_state("Aus");
              } else if (x[6]==0x01) { id(status_kessel).publish_state("An");
              } else { id(status_kessel).publish_state("Unknown");
            }

#VL Soll
# SvdE: not found
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xD2 && x[2]==0x02) {
              float temperature = float((float((int((x[4])+((x[3])<<8))))/10));
              id(vl_soll).publish_state(temperature);
              ESP_LOGD("main", "Temperature received over can is %f", temperature);
            }

#Show data in raw form as hex-values
    - can_id: 0x180
      then:
        - lambda: |-
            int wert0 = int(x[0]);
            int wert1 = int(x[1]);
            int wert2 = int(x[2]);
            int wert3 = int(x[3]);
            int wert4 = int(x[4]);
            int wert5 = int(x[5]);
            int wert6 = int(x[6]);
            float wert7 = float(int((x[6])+((x[5])<<8)));
            ESP_LOGD("main", "Antwort von 180 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
            ESP_LOGD("main", "Antwort von 180 Float: %f", wert7);
            ESP_LOGI("main", "Antwort von 180 Dez.: %i %i", wert5, wert6);

#Show data in raw form as hex-values
    - can_id: 0x300
      then:
        - lambda: |-
            int wert0 = int(x[0]);
            int wert1 = int(x[1]);
            int wert2 = int(x[2]);
            int wert3 = int(x[3]);
            int wert4 = int(x[4]);
            int wert5 = int(x[5]);
            int wert6 = int(x[6]);
            float wert7 = float(int((x[6])+((x[5])<<8)));
            ESP_LOGD("main", "Antwort von 300 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
            ESP_LOGD("main", "Antwort von 300 Float: %f", wert7);
            ESP_LOGI("main", "Antwort von 300 Dez.: %i %i", wert5, wert6);

#Show data in raw form as hex-values
    - can_id: 0x310
      then:
        - lambda: |-
            int wert0 = int(x[0]);
            int wert1 = int(x[1]);
            int wert2 = int(x[2]);
            int wert3 = int(x[3]);
            int wert4 = int(x[4]);
            int wert5 = int(x[5]);
            int wert6 = int(x[6]);
            float wert7 = float(int((x[6])+((x[5])<<8)));
            ESP_LOGD("main", "Antwort von 310 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
            ESP_LOGD("main", "Antwort von 310 Float: %f", wert7);
            ESP_LOGI("main", "Antwort von 310 Dez.: %i %i", wert5, wert6);

#Show data in raw form as hex-values
    - can_id: 0x500
      then:
        - lambda: |-
            int wert0 = int(x[0]);
            int wert1 = int(x[1]);
            int wert2 = int(x[2]);
            int wert3 = int(x[3]);
            int wert4 = int(x[4]);
            int wert5 = int(x[5]);
            int wert6 = int(x[6]);
            float wert7 = float(int((x[6])+((x[5])<<8)));
            ESP_LOGD("main", "Antwort von 500 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
            ESP_LOGD("main", "Antwort von 500 Float: %f", wert7);
            ESP_LOGI("main", "Antwort von 500 Dez.: %i %i", wert5, wert6);

#Show data in raw form as hex-values
    - can_id: 0x600
      then:
        - lambda: |-
            int wert0 = int(x[0]);
            int wert1 = int(x[1]);
            int wert2 = int(x[2]);
            int wert3 = int(x[3]);
            int wert4 = int(x[4]);
            int wert5 = int(x[5]);
            int wert6 = int(x[6]);
            float wert7 = float(int((x[6])+((x[5])<<8)));
            ESP_LOGD("main", "Antwort von 600 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
            ESP_LOGD("main", "Antwort von 600 Float: %f", wert7);
            ESP_LOGI("main", "Antwort von 600 Dez.: %i %i", wert5, wert6);

#Show data in raw form as hex-values
    - can_id: 0x680
      then:
        - lambda: |-
            int wert0 = int(x[0]);
            int wert1 = int(x[1]);
            int wert2 = int(x[2]);
            int wert3 = int(x[3]);
            int wert4 = int(x[4]);
            int wert5 = int(x[5]);
            int wert6 = int(x[6]);
            float wert7 = float(int((x[6])+((x[5])<<8)));
            ESP_LOGD("main", "Antwort von 680 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
            ESP_LOGD("main", "Antwort von 680 Float: %f", wert7);
            ESP_LOGI("main", "Antwort von 680 Dez.: %i %i", wert5, wert6);
